@ The stack switching logic for the arm thumb instruction set.
@ Written by Richard Tew, 2nd May 2006.
@
@ It is not possible to do this as inline assembler as gcc generates functions
@ where the stack register is preserved, so any changes we make to it will be
@ discarded.  However, any stack copying we have done is left in place, which
@ results in corrupt state.
@
@ This adapts the MASM approach written by Kristjan Jonsson, where early
@ returns from SLP_SAVE_STATE (within slp_save_state) are flagged by setting
@ the low bit of the return value.  This either indicates that there was an
@ error (-1) or that we do not need to restore the stack (1) as we are only
@ here to save the current one.
@
@ I know little arm thumb assembly, so in case anyone else wants to know the
@ approach I took, I will document it here.  The first uncertainty was which
@ registers should be saved.  I took this section of code from the assembler
@ generated by gcc with a command line of:
@     gcc -mthumb -S slp_transfer.c
@ where slp_transfer included the inline version of slp_switch for the arm
@ thumb.  Another initial uncertainty were the instructions needed to:
@     a) obtain the stack pointer.    (mov r0, sp)
@     b) restore the stack pointer.   (add sp, sp, r0)
@ which were used in the original inlined assembly.  The rest of the code was
@ just patched together based on Kristjan's existing masm source code

@ Addendum 2016-01-06: Kristjan Valur Jonssons
@ Converted to tealet semantics
@ This means that the functions to save and restore state, plus an argument
@ are passed to the function.  These must be stored in nv registers.
@ The early exit condition is different, we return if bit 0 is set.
@ state_save returns absolute PC, not an offset.
@ finally, branching to dynamic addresses is a bit complicated in thumb, where
@ the address must have 1 in the lowest bit.

@ (void *) tealet_slp_switch (save_func, restore_func, arg);
	.thumb
	.align	2
	.global	tealet_slp_switch
	.type	tealet_slp_switch, %function	@ Apparently useful for .map files.
	.thumb_func

tealet_slp_switch:
	push	{r4-r7, lr}
	mov	r7, r11
	mov	r6, r10
	mov	r5, r9
	mov	r4, r8
	push	{r4-r7}
	@ additional register saves would come here
	add	r7, sp, #28			@ thumb fp, points to saved s7 

	@ save call arguments
	@ note that these must be constant for all switches, we
	@ cannot save them on stack and restore a value for after switch
	mov	r4, r0	@ save_state
	mov	r5, r1  @ restore_state
	mov	r6, r2	@ arg

	@ save state call.

	mov	r0, sp
	mov	r1, r6
	mov	r2, #1	@ set bit 0 of branch address to 1 for blx
	orr	r2, r2, r4
	blx	r2	@ sp = (*save_func)(stackref, arg)

	@ is the return value odd ?
	mov	r1, #1				@ test low order bit
	tst	r0, r1
	bne	.exit				@ return r0 if not zero;

.restore:
	mov	sp, r0				@ Adjust the stack pointer for the state we are restoring.

	mov	r1, r6
	mov	r2, #1
	orr	r2, r2, r5
	blx	r5	@ sp = (*restore_func)(stackref, arg)

.exit:
	pop	{r2, r3, r4, r5}
	mov	r8, r2
	mov	r9, r3
	mov	r10, r4
	mov	r11, r5
	pop	{r4-r7, pc}

	.size	tealet_slp_switch, .-tealet_slp_switch	@ Apparently useful for .map files.
